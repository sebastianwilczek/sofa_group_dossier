\section{Implementation}
\label{sec:implementation}
\lhead{\thesection \space Implementation}

This chapter details how the \textit{Vote4Fun} extension was implemented over the course of the project, based on the design described in \textit{\ref{sec:desgin} \nameref{sec:desgin}}. To do so, the implementation of the Setup Wizard is explained first. Given the component-based structure of \textit{React Native}, each component that makes up the Setup Wizard is explained, as they are defined in Figure \ref{fig:component_diagram_wizard} in \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}}. Each component section contains a simplified version of it's source code to highlight important points about their implementation. The entire structure of the Wizard is described too, as well as how each child component interacts with it using callback functions.
\newline
The description of the individual components is followed by a definition of functional components, as well as how they were used during the project in combination with \textit{recompose}. It is detailed how to write functional components and why it is a good idea to use them. This section also includes an overview and description of the functionality of \textit{recompose} that was used in the extension.
\newline
What follows is a description of how \textit{GraphQL} was used during the project. It briefly details what \textit{GraphQL} is and what makes it great to use. This is followed by an explanation of how it was implemented in the application and where it was used as part of the extension.
\newline
The chapter closes with a section about the problems occurring during development. The problems described deal with the way \textit{React Native} applications can be debugged and why that way is less efficient than it could be as well as problems occurring because of \textit{Node.js} packages being used, including a way to fix most problems related to this issue. It is also detailed how configuration errors took place during the implementation, specifically how the application failed to be deployed to an \textit{iOS} device.

\subsection{Poll Wizard}
\label{ssec:poll_wizard}

The Poll Wizard is mostly defined by the \textit{WizardProcess} component. A simplified version of this component can be seen in Listing \ref{lst:wizardComponentWithRecompose}. All source code that does not relate to the staging functionality of the Wizard was removed from the code below.

\begin{lstlisting}[language=javascript,caption=Simplified Wizard Component using \textit{recompose},label=lst:wizardComponentWithRecompose]
const WizardProcess = ({stage, incrementStage, decrementStage}) => {
  return (
    <View>
      {stage == 0 && <WizardStageTitle />}
      {stage == 1 && <WizardStageTeam />}
      {stage == 2 && <WizardStageGuests />}
      {stage == 3 && <WizardStageExercises />}
      {stage == 4 && <WizardStageDueDate />}
      {stage == 5 && <WizardStageCheck />}

      <View>
        {stage != 0 && (
          <TouchableOpacity onPress={decrementStage}>
            <Icon name='arrow-circle-left' size={60} />
          </TouchableOpacity>
        )}
        {(stage >= 0 && stage <= 4) &&
          <TouchableOpacity onPress={incrementStage}>
            <Icon name='arrow-circle-right' size={60} />
          </TouchableOpacity>
        }
        {stage == 5 && (
          <TouchableOpacity onPress={buildVote4FunObject}>
            <Icon name='check-circle' size={60} />
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}
export default compose(
  withState('stage', 'setStage', 0),
  withHandlers({
    incrementStage: props => () => {props.setStage(props.stage + 1)},
    decrementStage: props => () => {props.setStage(props.stage - 1)},
  mapProps(props => ({
    stage: props.stage,
    incrementStage: props.incrementStage,
    decrementStage: props.decrementStage,
  }))
)(WizardProcess)
\end{lstlisting}

The component is actually divided into two components, making use of \textit{recompose}. For further information about \textit{recompose}, see \textit{\ref{ssec:recompose} \nameref{ssec:recompose}}. The first part is a functional component, which takes a numerical value for \textit{stage} as well as functions to change this value as parameters. Depending on the value of \textit{stage}, different components are rendered, as described in \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}}. The component furthermore renders buttons depending on certain \textit{stage} values, to advance through the stages of the Setup Wizard. The complete component also implements certain checks at this point, for example by only showing the advancing button when a title has been entered in the \textit{WizardStageTitle} component.
\newline
The second part of the component defines the business logic of the component. It uses \textit{recompose} to provide state, in this example to the property \textit{stage}. The full component defines the entire state of all mutable values here, including the handlers to change them. These handlers are used as callback methods by the \textit{WizardStage} components to store entered values. All values and functions created this way are also mapped as properties, so that they can be used by the functional rendering component.
\newline
Since the component strictly separates rendering and logic, the component can easily be expanded. More stages could potentially be added or removed. Given the right handlers, stages could also be skipped or jumped to.

\subsubsection{Poll Title}
\label{sssec:poll_title}

The \textit{WizardStageTitle} component, as it is seen in Listing \ref{lst:pollTitleComponent}, is a fairly simple one. It shows a text input field for the user to put in the name of the poll. Just like \textit{WizardProcess}, it is a functional component, albeit without \textit{recompose}.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Title Component,label=lst:pollTitleComponent]
const WizardStageTitle = (props) => {
  if (props.title.length == 0) {
    props.updateTitle("Poll: " + props.trainingTitle)
  }
  return (
    <View style={props.styles.stageContainer}>
      <Text style={props.styles.header}>
        {I18n.t('SOFA_wizard_header_title')}
      </Text>
      <FormTextInput
        value={props.title}
        label=''
        maxLength={50}
        placeholder={`${I18n.t('SOFA_wizard_title_placeholder')}`}
        onChangeText={props.updateTitle} />
    </View>
  );
};
export default WizardStageTitle;
\end{lstlisting}

If the component is initialised the first time, still having an empty string as a value for \textit{title}, which is given to the component as a property, the component gives it a default value, consisting of the value "Poll: " and the original training title, which is also a property. In \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}} you can see that the training title is in turn provided as a property to the \textit{WizardProcess} component.
\newline
Other than that, the component makes use of the \textit{FormTextInput}, which is a custom styled text entry field component. The callback function is referenced in the "onChangeText" property. Furthermore, the component is referencing the \textit{I18n} component, which can load specified strings for different languages, making it easy to translate the application into different languages and changing them as needed. The style of the components is also loaded as property, since \textit{WizardProcess} defines most styles to keep the style consistent throughout all \textit{WizardStage} components.

\subsubsection{Team Selection}
\label{sssec:poll_team}

\textit{TeamPicker} was invented for the the user with the role coach so that he is able to pick a team that is able to vote for exercises. Class \textit{TeamPicker} extends a Component and has the method "onValueChange", this means if a value changes \textit{React Native} triggers the render method. There is a case if the coach only has one team, the component would not trigger the render and the \textit{TeamPicker} settings would not write into the \textit{TeamGraphql} object. This object will at the end display all selected settings the user with the role coach made over the setup. It maps over the object 

\begin{lstlisting}
import React, { Component } from 'react';
import { View, Picker} from 'react-native';
class TeamPicker extends Component {
  render() {
    return (
      <View style = {{marginTop: '50%', marginLeft: '25%',
      marginRight: '25%', width: '50%'}}>
        <Picker selectedValue = {this.props.team}
         onValueChange = {this.props.updateTeam}>
          { this.props.query.map(
              element => (
              <Picker.Item styles = {{textAlign: 'center'}}
                key={element.teamInfo.teamId}
                label={element.teamInfo.teamName}
                value={element.teamInfo.teamId}
            />),
          )}
        </Picker>
      </View>
    );
  }
}
export default TeamPicker;
\end{lstlisting}

\subsubsection{Addition of Guests}
\label{sssec:poll_guests}

The \textit{WizardStageGuests} component allows the user to invite guests via email to participate in the voting for the exercise for a specific training. One condition for this is that the email that is invite to the poll is already registered in the \textit{Connected.Football} environment. 
\newline
The structure of the component in Listing \ref{lst:pollGuestsComponent} is fairly simple. It has a text input where the user can enter an email and a button that will then check this email and when the check returns true, it will add the email to a \textit{FlatList}. 
\begin{lstlisting}[language=javascript, caption=Simplified Guest Component, label=lst:pollGuestsComponent]
return (
    <ApolloConsumer>
      {client => ...
        }
        return (
          <View>
            <View style={props.styles.stageContainer}>
              <Text style={props.styles.header}>
                {I18n.t('SOFA_wizard_header_guests')}
              </Text>
              <FormTextInput
                value={props.email}
                label={`${I18n.t('SOFA_wizard_guests_email')}`}
                maxLength={50}
                type='email-address'
                placeholder={`${I18n.t('SOFA_wizard_guests_enter_email')}`}
                onChangeText={props.updateEmail}
              />
              <Button
                title={`${I18n.t('SOFA_wizard_guests_add_button')}`}
                color='green'
                onPress={onPress}
              />
            </View>
            <FlatList
              data={props.emailArray}
              extraData={props.updateView}
              renderItem={({ item }) => (
              ...
              )}
              keyExtractor={(item, index) => index.toString()}
            />
          </View>
        )
      }}
    </ApolloConsumer>
  )
}
\end{lstlisting}

In Listing \ref{lst:pollGuestsCheck} the methods that check the email on the offline part (no connection to the \textit{Connected.Football} environment) are shown. The method \textit{validateEmail} gets an email as a parameter and then checks the email if the email has the standard email format. The second method checks if the email is already in the \textit{emailArray}. This way the \textit{FlatList} can't have the same email twice.

\begin{lstlisting}[language=javascript, caption=Check E-Mail Methods, label=lst:pollGuestsCheck]
const validateEmail = email => {
  var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}
    \.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
  return re.test(email)
}
const isDoubleEmail = (value, array) => {
  const bufArray = array
  let doubleEmail = false
  bufArray.find(item => {
    if (item.email === value) {
      doubleEmail = true
    }
  })
  return doubleEmail
}
\end{lstlisting}

In Listing \ref{lst:pollGuestGraphQLCheck} the client is shown that executes the \textit{GraphQL}. There also is the \textit{onPress} method that is executed as soon as the user presses the add button in the \textit{GuestStage}. The \textit{onPress} method then first checks if the email is valid and if it was already added to the \textit{emailArray}. If all the checks return true, the \textit{executeQuery} method is executed. 
\newline
The \textit{executeQuery} method is a Asynchronous method that executes a \textit{GraphQL} query with the help of Apollo. Therefore it needs a \textit{GraphQL} query that is saved in the variable \textit{EMAIL\_QUERY} and the email as a parameter that will be added to the \textit{EMAIL\_QUERY}. After the query was execute the result can be fetched with the \textit{then} method. In this method the result is then checked if the query returned null. If the query returned null then a notification will be shown for the user to inform him that the email is not registered in the \textit{Connected.Football} environment. When the query returned something else then null then the email is added to the \textit{FlatList} and to the \textit{emailArray}.

\begin{lstlisting}[language=javascript, caption=Check in \textit{Connected.Football} environment, label=lst:pollGuestGraphQLCheck]
client => {
        const executeQuery = async () => {
          await client
            .query({
              query: EMAIL_QUERY,
              variables: {
                email: props.email
              },
              fetchPolicy: 'network-only'
            })
            .then(response => { 
              //console.warn(response)
              if (response.data.checkUserPresenceWithinClubByEmail !== null) {
                const bufArray = props.emailArray
                bufArray.push({ email: props.email })
                props.emailArray = [...props.emailArray, ...bufArray]
                props.refresh()
              } else {
                HelpNotification('emailNotInConnectedFootball')
              }
            })
            .catch(err => {
              console.warn(err)
            })
        }
        const onPress = () => {
          if (validateEmail(props.email)) {
            if (!isDoubleEmail(props.email, props.emailArray)) {
              executeQuery()
            } else {
              HelpNotification('emailDouble')
            }
          } else {
            HelpNotification('emailNotValid')
          }
        }
\end{lstlisting}

\subsubsection{Choice of Exercises}
\label{sssec:poll_exercises}

The \textit{WizardStageExercises} component is used to select the exercises voted upon. To achieve this three arrays are utilised:

\begin{itemize}
    \item \textit{allExercises}\\
    Contains all exercises. This array is filled by a \textit{GraphQL} query shown in listing \ref{lst:selectAll}.
    \item \textit{selectedExercises}\\
    Contains the exercises that are already selected for the training by the coach. This array is passed down to the wizard by the parent component.
    \item \textit{pollExercises}\\
    Contains the exercises that players will be able to vote upon. This array is created by the wizard.
\end{itemize}

As you can see in the query to get all the exercises in listing \ref{lst:selectAll} an exercise object consists of different fields containing for example the id, a title and a uri to an image.

\begin{lstlisting}[language=javascript, caption=\textit{GraphQL} Query AllExercises, label=lst:selectAll]
const EXERCISE_QUERY = gql`
  query PublicExercises {
    getAllExercises(trainingType: "team") {
      id
      title
      taxonomy
      image
      animation
      gif
    }
  }
`;
\end{lstlisting}

The main goal of this component is to fill the \textit{pollExercises} array with the exercises the coach selects. It has to be ensured that every exercise is selected only once and that it is not already part of the regular training. In listing \ref{lst:selectContains} a method to check whether a exercise is already part of an array is shown.

\begin{lstlisting}[language=javascript, caption=Check Include Method, label=lst:selectContains]
const includesExercise = (array, item) => {
  // return value
  let ret = false;

  // go through the list and check if a entry with the items id is contained
  array.forEach(function (entry) {
    if (item.id == entry.id) {
      ret = true;
    }
  });

  return ret;
}
\end{lstlisting}

This method is then used for defining if an exercise should be displayed for selection to the coach when choosing the poll exercises as shown in listing \ref{lst:selectDisplay}.

\begin{lstlisting}[language=javascript, caption=Display Exercise Method, label=lst:selectDisplay]
const isDisplay = (item, pollExercises, selectedExercises) => {
  // return value
  let ret = false;

  // check if item is already part of the training
  ret = includesExercise(selectedExercises, item);

  // if not, check if item is already selected to be voted on
  if (!ret) {
    ret = includesExercise(pollExercises, item);
  }

  return !ret;
}
\end{lstlisting}

All of the above is then utilised to display the selectable exercises in a flat list as shown in listing \ref{lst:selectListPick}:

\begin{lstlisting}[language=javascript, caption=\textit{FlatList} Selectable, label=lst:selectListPick]
        <FlatList
          data={this.props.allExercises}
          extraData={this.props.updateView}
          keyExtractor={keyExtractor}
          renderItem={({ item }) => (
            <View>
              {isDisplay(item, this.props.pollExercises, this.props.selectedExercises) &&
                <View style={{ flexDirection: 'row', height: 50 }}>
                  <Button
                    onPress={() => {
                      this.props.pollExercises.push(item)
                      this.props.refresh()
                    }}
                    title="+"
                    backgroundColor="#C9C9C9"
                  />
                  <FastImage
                    style={{ width: 50, height: 50 }}
                    source={{ uri: item.image }}
                    resizeMode={FastImage.resizeMode.contain}
                  />
                  <Text>{item.title}</Text>
                </View>
              }
            </View>
          )}
        />
\end{lstlisting}

Similar to this the selected exercises contained in \textit{pollExercises} are also displayed in a \textit{FlatList} alongside buttons to remove the specified exercise from the list:

\begin{lstlisting}[language=javascript, caption=\textit{FlatList} Selected, label=lst:selectListSelected]
        <FlatList
          data={this.props.pollExercises}
          extraData={this.props.updateView}
          keyExtractor={keyExtractor}
          renderItem={({ item }) => (
            <View>
              <View style={{ flexDirection: 'row', height: 50 }}>
                <Button
                  onPress={() => {
                    this.props.pollExercises.splice(this.props.pollExercises.indexOf(item), 1)
                    this.props.refresh()
                  }}
                  title="-"
                  backgroundColor="#C9C9C9"
                />
                <FastImage
                  style={{ width: 50, height: 50 }}
                  source={{ uri: item.image }}
                  resizeMode={FastImage.resizeMode.contain}
                />
                <Text>{item.title}</Text>
              </View>
            </View>
          )}
        />
\end{lstlisting}

One may wonder what the "extraData" field in the \textit{FlatList} is about. It turns out that on a data change a re-rendering of the component is not automatically done, but changing the provided "extraData" triggers a re-rendering of the component. That also explains why "this.props.refresh()" needs to be called after every change in the underlying data.

\subsubsection{Due Date Settings}
\label{sssec:poll_due_date}

The component that takes user input regarding the due date of a poll, which is called \textit{WizardStageDueDate}, as seen in Listing \ref{lst:pollDueDateComponent}, is very similar to the component mentioned in \textit{\ref{sssec:poll_title} \nameref{sssec:poll_title}}. It is again a simple functional component which receives relevant values as properties to render the user input field.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Due Date Component,label=lst:pollDueDateComponent]
const WizardStageDueDate = (props) => {
  return (
    <View style={props.styles.stageContainer}>
      <Text style={props.styles.header}>
        {I18n.t('SOFA_wizard_header_due_date')}
      </Text>
      <DateTimePicker
        label="SOFA_wizard_due_date"
        trainingDate={props.dueDate}
        setTrainingDate={props.updateDueDate}
      />
      <View style={styles.hintContainer}>
        <Text style={styles.hintText}>
          {I18n.t('SOFA_wizard_due_date_hint')}
        </Text>
      </View>
    </View>
  );
};
export default WizardStageDueDate;
\end{lstlisting}

The component makes use of another component called \textit{DateTimePicker}, which is a custom component that opens a dialog which is native to the mobile OS the application was deployed to, which lets the user pick a date and time. Once a user has chosen a time, the component calls the supplied callback function, in this case "updateDueDate".
\newline
Given the nature of a poll, this due date of course has to be before the date of the actual training. Such a check is absent in the component mentioned above. The actual check is done by the \textit{WizardProcess} component, which handles most of the logic.

\begin{lstlisting}[language=javascript,caption=Increment Stage Check,label=lst:incrementStageCheck]
{((stage == 0 && title != '') ||
   stage == 1 ||
   stage == 2 ||
   stage == 3 ||
   ((stage == 4) && (dueDate > new Date().addDays(1)) && (dueDate.addHours(2) < trainingDate))
) &&
  <TouchableOpacity onPress={incrementStage}>
    <Icon name='arrow-circle-right' size={60} />
  </TouchableOpacity>
}
\end{lstlisting}

The source code listed in Listing \ref{lst:incrementStageCheck} shows the check as to whether to show the button which advances the Setup Wizard to it's next stage. The button is only rendered when certain conditions are met, for instance, in stage 0, which makes use of the component \textit{WizardStageTitle}, the title itself must not be empty. In the same way, the entered due date must be at least one day in the future, so that users have time to vote, and at least two hours before the start of the training.
\newline
As far as state is concerned, the component acts the same way as \textit{WizardStageTitle}. Once the callback function is called, the state is stored into the variable "dueDate" and is available to be used in the entire Setup Wizard components and it's sub-components.

\subsubsection{Check of Settings}
\label{sssec:poll_check}

Listing \ref{lst:pollCheckComponent} shows a simplified version of the \textit{WizardStageCheck} component. Again a functional component, the component seems to include quite a lot, yet it is actually only responsible for showing the already entered values to the user. The amount of source code simply comes from the amount of information that needs to be displayed, which includes information from all previous \textit{WizardStage} components.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Check Component,label=lst:pollCheckComponent]
const WizardStageCheck = (props) => {
  return (
    <View>
      <Text>{I18n.t('SOFA_wizard_header_check')}</Text>
      <View>
        <FormLabel>{I18n.t('SOFA_wizard_title')}</FormLabel>
        <View>
          <Text>{props.title}</Text>
        </View>
        {props.emailArray.length > 0 &&
          <View>
            <FormLabel>{I18n.t('SOFA_wizard_guests')}</FormLabel>
            <View>
              <FlatList
                data={props.emailArray}
                renderItem={({ item }) => (
                  <View>
                    <Text>{item.email}</Text>
                  </View>
                )}
                keyExtractor={(item, index) => index.toString()}/>
            </View>
          </View>
        }
        <FormLabel>{I18n.t('SOFA_wizard_exercises')}</FormLabel>
        <View>
          <Text>{props.pollExercises}</Text>
        </View>
        <FormLabel>{I18n.t('SOFA_wizard_due_date')}</FormLabel>
        <View>
          <Icon name="date-range" size={40} />
          <Text>{moment(props.dueDate).format('DD-MM-YYYY H:mm')}</Text>
        </View>
      </View>
    </View>
  );
};
export default WizardStageCheck;
\end{lstlisting}

The component itself does not actually trigger any callback method, as the interaction for sending the checked information is actually part of the stage buttons displayed by the \textit{WizardProcess} component. Listing \ref{lst:wizardComponentWithRecompose} in \textit{\ref{ssec:poll_wizard} \nameref{ssec:poll_wizard}} contains the button which calls the handler method "buildVote4FunObject", which is responsible for sending the entered information to the \textit{Connected.Football} backend. This handler method can be seen in Listing \ref{lst:buildVote4FunObject}.

\begin{lstlisting}[language=javascript,caption=\textit{buildVote4FunObject} Handler Method,label=lst:buildVote4FunObject]
[...]
export default compose(
  //[...]
  withHandlers({
    buildVote4FunObject: props => () => {
      const exercises = [];
      props.pollExercises.forEach(function (entry) {
        exercises.push({ "exerciseId": entry.id, "playerIds": [] });
      })
      const v4l = {
        "type": "clubteam",
        "title": props.title,
        "deadline": props.dueDate,
        "showIntermediaResults": false,
        "showFinalResults": false,
        "notificationHoursBeforeDeadline": 1,
        "notificationAfterPercentageVoted": 50,
        "guestIDs": emailArray,
        "exercises": exercises
      }
      props.action({ type: 'setVote4Fun', text:v4l });
      props.navigator.pop();
    },
  }),
  //[...]
)(WizardProcess)
\end{lstlisting}

This method builds a JSON object that consists of all the information entered by the user as well as some default values that can be changed by the owner of the poll later, such as whether to show intermediate results or when to send notifications to users. One thing to pay attention to is how the "exercises" array is constructed. The array does not only consist of the IDs of exercises but is build of objects containing both one the mentioned IDs as well as an empty array called "playerIds". This empty array is later filled with the ID of an user, whenever this user votes for this specific exercise in the poll. This way it can be tracked who already voted and which exercises got how many views.
\newline
The constructed JSON object is then propagated to the "action" property. This property is handed down from the component creating the training planner, which includes the storing of said object as well as the \textit{GraphQL} mutation to store the poll together with the entire training plan. A simplified version of this functionality can be seen in Listing \ref{lst:trainingPlannerGraphQL}.

\begin{lstlisting}[language=javascript,caption=Simplified Training Planner Component with \textit{GraphQL} Mutation,label=lst:trainingPlannerGraphQL]
const actions = {
  //[...]
  setVote4Fun: (s, action) => Object.assign({}, s, {
    vote4fun: action.text,
  }),
};
//[...]
const SAVE_PROGRAM_MUTATION = gql`
  mutation SaveProgram($payload: JSON!) {
    saveProgram(payload: $payload) {
        data
        ...ProgramListItem
      }
  }
  ${PROGRAM_LIST_FRAGMENT}
`;
//[...]
export default compose(
  //[...]
  graphql(SAVE_PROGRAM_MUTATION),
  withReducer('programState', 'action', reducer, ({ program }) => {
    return {
      id: program.id,
      //[...]
      vote4fun: program.vote4fun || [],
    };
  }),
  withHandlers({
    saveProgram: props => () => {
      props.mutate({
        variables: {
          payload: transformReducerToPayload(props.programState),
        },
        update: (store, { data: { saveProgram } }) => {
          const data = store.readQuery({ query: PROGRAMS_QUERY });
          data.getPrograms.unshift(saveProgram);
          store.writeQuery({ query: PROGRAMS_QUERY, data });
        },
      });;
    },
  ),
)(TabView);
\end{lstlisting}

The "action" that is given to the Setup Wizard is defined at the very beginning. This callback simply receives the input of the callback call and stores the text that comes with it in a variable "vote4fun". The rest shows how all entered values of a training, including the values entered in the Setup Wizard, are merged into a "reducer" which is in turn sent as a \textit{GraphQL} mutation.
\newline
The mutation itself is defined in the lines 8-15. The mutation references "SaveProgram", which is a mutation endpoint provided by the \textit{Connected.Football} backend. The sent object itself is defined with \textit{recompose}'s "withReducer", which returns all values of a training program, including the "vote4fun" value, as a JSON object. Note that if the value "vote4fun" is null, an empty array is sent instead, since a training planner does not necessarily require a poll to be created.
\newline
Finally, the handler method "saveProgram" takes this reducer and sends it to the backend. The reducer is taken as a payload for the mutation. The mutation returns the ID of the created training program, which can be used for other functionality, such as editing the training program. Since the "vote4fun" object is part of said program, it is of course also possible to edit the poll itself.

\subsection{\textit{recompose} \& Functional Components}
\label{ssec:recompose}

\textit{recompose} is a \textit{Node.js} package which is available at \url{https://www.npmjs.com/package/recompose}. It was made heavily use of during the project because of the possibility to completely divide logic and rendering inside the same component. All major components described in \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}} are functional components. An example of a functional component can be seen in Listing \ref{lst:functionalComponent}.

\begin{lstlisting}[language=javascript,caption=Functional Component Example,label=lst:functionalComponent]
const Component = prop => (
  <View>
    <ChildComponent />
  </View>
);
\end{lstlisting}

Depending on individual preference, the strict functional arrow representation may also be extended with the "return" keyword for easier readability. The one thing to notice about such a functional component is that it does not implement any form of state or state management. What makes a functional component functional is that it is supplied with some form of state, such as properties or other state-forming values, and that it returns something that is dependent on that state, in this case a \textit{React Native} rendering definition. Given that the functional component is not dependent on how the state is managed, it can be reused in any way necessary. Two or more implementations of state and state management can make use of the same functional component without ever needing to change the component itself. The only restriction is that if the same state is supplied to the component, the result is always the same, since it does not make use or references any other form of state. For this reason, functional components are also known as stateless components.
\newline
To implement any business logic, \textit{recompose} comes into play. A simple example of the usage of \textit{recompose} can be seen in Listing \ref{lst:wizardComponentWithRecompose} in \textit{\ref{ssec:poll_wizard} \nameref{ssec:poll_wizard}}. The component defined there contains a functional component called \textit{WizardProcess} which is supplied with the properties \textit{stage}, \textit{incrementStage} and \textit{decrementStage}, which make up the state and the state management. Assuming that these properties do not change, the returned \textit{React Native} rendering always acts the exact same way.
\newline
Table \ref{tab:recomposeFunctions} shows the basic functionality and keywords of \textit{recompose}. The following description explains how to use the mentioned keywords and how they were implemented in the project.

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{ |l|X| }
        \hline
        \rowcolor[HTML]{C0C0C0} 
        \textbf{Name}              & \textbf{Usage}                                                                                                                  \\ \hline
        \textit{withState}         & Manages a single state value, providing a function to update the value and accepting an optional default value.                 \\ \hline
        \textit{withHandlers}      & Creates handler methods, which are functions that do things in response to events being triggered, accepting component's props. \\ \hline
        \textit{mapProps}          & Replaces the current props with properties given inside the function.                                                           \\ \hline
        \textit{withProps}         & Merges the current props with properties given inside the function.                                                             \\ \hline
        \textit{onlyUpdateForKeys} & Limits the re-rendering of the component to changes in state defined inside the function.                                       \\ \hline
    \end{tabularx}
    \caption{\textit{recompose} Functions}
    \label{tab:recomposeFunctions}
\end{table}

The actual definition of these properties is handled by using \textit{recompose}. Making use of the "compose" command, various state and logic definitions can be supplied to the functional component, which is references in brackets at the very end. Using the "withState" keyword, the state, which is as aforementioned absent from the functional component, can be defined. Each state has a name, a name for a method which can overwrite the value of the state and default value. In the example that is "stage", "setStage" and 0, respectively. This state is initialised whenever the component using \textit{recompose} is used in another component.
\newline
Stage management and business logic can be applied to a functional component with the "withHandlers" keyword. The keyword allows the definition of multiple methods which can alter the state defined above. Take note that these methods are also functions, taking the entire state that is also applied to the functional component as function values, called "props". The function defined this way can make use of the methods defined with the "withState" keyword to alter the state of the defined values. In the example, the functions make use of the "setStage" method, incrementing or decrementing them by calling the state of "stage" and applying the new state using the aforementioned method.
\newline
The state and function defined previously can be mapped to be used as properties by the functional component and by the other function defined using \textit{recompose}. The "mapProps" keyword can be used for that. Since the component might also receive properties from a higher level component, these can be used here as well, using the "withProps" keyword. This way, it is also possible to prevent name collisions, when a property that is used internally has the same name as a property that is handed down by a parent component.
\newline
The great thing about defining handler methods this way is that they can be used as properties the same way as the state itself. This way, it is possible to hand down the logic defined in this component to child components, which can use the references to the handler methods as callback functions. This principle was applied to the \textit{WizardStage} components in this project. This way, the aforementioned components could be entirely functional. All they needed to implement was how the component was supposed to be rendered given the properties it receives and what part of the rendering would need to call the handler methods. It could also be limited which properties were given to certain components. Making use of that, components would only need to render or re-render whenever the properties that are relevant to them change.
\newline
Considering limiting re-rendering, \textit{recompose} can also be of use that way. The "onlyUpdateForKeys" keyword allows it to define the names of certain state values. When a state value changes that is not part of this set, the rendering will not take place for the component. For example, this can be very useful when the changed state is only needed for internal computation and is not visible to the user. This significantly reduces overhead by stopping unnecessary re-rendering.

\subsection{\textit{GraphQL}}
\label{ssec:graphql}

\textit{GraphQL} is used as a framework for REST that is developed by Facebook in 2012 and released to the public in 2015. \textit{GraphQL} allows users to define the structure of the required data, to retrieve the exact data the user asks for. \textit{GraphQL} provides only one endpoint and lets user change data through so called mutations. To query for data, the keyword query is used. With the help of this framework increasing programs do not get messy when it comes to REST API calls. \textit{GraphQL} can not only be used for \textit{JavaScript}, there are server libraries for nearly every programming language out there.
\newline
The \textit{Connected.Football} application uses \textit{GraphQL} for communication between the frontend and the backend. On the backend several \textit{GraphQL} functions are defined that the frontend uses to get data from the backend. As an example in section \ref{sssec:poll_guests} the entered email was send to the backend to check if it was already registered in the \textit{Connected.Football} environment. Therefore a \textit{GraphQL} query in the frontend was defined. This query then calls on a function on the backend that expects an email. If this query finds an email that is equal to the one that was given the function as a parameter then the function returns the id of the user. When the query doesn't find an email then it returns true. 


\subsection{Problems \& Caveats}
\label{ssec:problems}

Throughout the project the group encountered various problems with \textit{React Native}. The main concern hereby is that the technology is brand new and many problems are not tackled in the web, as for now, \textit{React Native} is in version 0.57. Speeding up with the development was not possible since all the frameworks and the language \textit{JavaScript} had first to be learned and understood, including randomly encountered errors. This worked like a neck breaker in terms of finishing epics. Sometimes over the weekend the project did not work after getting back to it on Mondays and nobody knew why, even after a complete fresh new checkout plus clean and build from the master branch.

\subsubsection{Debugging}
\label{sssec:debugging}

 The normal procedure is that if an error is encountered, at the end, searching for it online often returns a fitting answer. However, not with \textit{React Native}, encountering problems and trying to search for related issues did not rarely end in hours of searching and ending up on Chinese web sites with no readable answer to the solutions. The error message was often somewhat cryptic and not meaningful at all, for example the message "Undefined is not a function". The group learned over time, that it is smarter to make tiny steps and change little by little and to directly compile and deploy the application afterwards. "Hotreloading" in this case caused many problems, sometimes it was not clear why the application is not working, "Hotreloading" is one of the newer features that immediately refreshes the code on the phone after the code has been saved. However, the problem with that is, that it does not recognise all changes and the developer has to recompile the entire application. Without knowing this, hours can be spent by trying to find an error that does not exist.
 \newline
 Debugging was quiet difficult with these problems, the best hint was to look up the \textit{GitHub} repository and look for fresh created threads about the issue that appeared while developing. If no related thread to the error could be found, it was often not possible to keep on developing with this problem.

\subsubsection{Package Management}
\label{sssec:package_management}

During this project there were several problems that put the project on hold. One of these problems was that the package manager for \textit{React Native}, \textit{NPM} would install minor package updates. These minor package updates then would lead to several error messages and crashes of the \textit{Connected.Football} application. The problem about those errors and crashes were that the logging information about those weren't that great. These errors and crashes resulted that the project came to a full stop several times and all the project members tried to solve the error or crash of the application. 
\newline
Sometimes these errors and crashes would solve themselves after a while, probably because another minor update on another dependency was made, which then solved the current crash or error. 
\newline
Very late in the project this problem then would be solved. The problem was that in the \textit{package.json} of the \textit{Connected.Football} application several dependencies were allowed to update for minor updates. In \textit{NPM} this was done by using the " \^\ " symbol in front of the version number of the dependencies. After removing all " \^\ " this error never reoccurred during this project. 

\subsubsection{Configuration Problems}
\label{sssec:configuration_problems}

The idea behind \textit{React Native} is quiet handy and fastens prototype development. Fine tuning can later be done with native developers. The problem to that is that the technology has not matured enough, so setting up the project on \textit{iOS} was way harder than setting it up and working with it on \textit{Android}.
\newline
To be able to let the code run on an \textit{iOS} device, a Mac and Xcode is needed. The group member Patrick Richter spent nearly 30 hours trying to debug issues and getting it up and running on \textit{iOS}. Even with the help of the customer, \textit{iOS} was insufficient to work with. Plenty of times the application would not boot, respond with errors or do nothing at all. Since this is the first project where \textit{React Native} has been used, errors can also be related to bad coding style of the application.