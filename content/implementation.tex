\section{Implementation}
\label{sec:implementation}
\lhead{\thesection \space Implementation}

TODO Sebastian

\subsection{Poll Wizard}
\label{ssec:poll_wizard}

The Poll Wizard is mostly defined by the \textit{WizardProcess} component. A simplified version of this component can be seen in Listing \ref{lst:wizardComponentWithRecompose}. All source code that does not relate to the staging functionality of the Wizard was removed from the code below.

\begin{lstlisting}[language=javascript,caption=Simplified Wizard Component using \textit{recompose},label=lst:wizardComponentWithRecompose]
const WizardProcess = ({stage, incrementStage, decrementStage}) => {
  return (
    <View>
      {stage == 0 && <WizardStageTitle />}
      {stage == 1 && <WizardStageTeam />}
      {stage == 2 && <WizardStageGuests />}
      {stage == 3 && <WizardStageExercises />}
      {stage == 4 && <WizardStageDueDate />}
      {stage == 5 && <WizardStageCheck />}

      <View>
        {stage != 0 && (
          <TouchableOpacity onPress={decrementStage}>
            <Icon name='arrow-circle-left' size={60} />
          </TouchableOpacity>
        )}
        {(stage >= 0 && stage <= 4) &&
          <TouchableOpacity onPress={incrementStage}>
            <Icon name='arrow-circle-right' size={60} />
          </TouchableOpacity>
        }
        {stage == 5 && (
          <TouchableOpacity onPress={buildVote4FunObject}>
            <Icon name='check-circle' size={60} />
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}
export default compose(
  withState('stage', 'setStage', 0),
  withHandlers({
    incrementStage: props => () => {props.setStage(props.stage + 1)},
    decrementStage: props => () => {props.setStage(props.stage - 1)},
  mapProps(props => ({
    stage: props.stage,
    incrementStage: props.incrementStage,
    decrementStage: props.decrementStage,
  }))
)(WizardProcess)
\end{lstlisting}

The component is actually divided into two components, making use of \textit{recompose}. For further information about \textit{recompose}, see \textit{\ref{ssec:recompose} \nameref{ssec:recompose}}. The first part is a functional component, which takes a numerical value for \textit{stage} as well as functions to change this value as parameters. Depending on the value of \textit{stage}, different components are rendered, as described in \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}}. The component furthermore renders buttons depending on certain \textit{stage} values, to advance through the stages of the Setup Wizard. The complete component also implements certain checks at this point, for example by only showing the advancing button when a title has been entered in the \textit{WizardStageTitle} component.
\newline
The second part of the component defines the business logic of the component. It uses \textit{recompose} to provide state, in this example to the property \textit{stage}. The full component defines the entire state of all mutable values here, including the handlers to change them. These handlers are used as callback methods by the \textit{WizardStage} components to store entered values. All values and functions created this way are also mapped as properties, so that they can be used by the functional rendering component.
\newline
Since the component strictly separates rendering and logic, the component can easily be expanded. More stages could potentially be added or removed. Given the right handlers, stages could also be skipped or jumped to.

\subsubsection{Poll Title}
\label{sssec:poll_title}

The \textit{WizardStageTitle} component, as it is seen in Listing \ref{lst:pollTitleComponent}, is a fairly simple one. It shows a text input field for the user to put in the name of the poll. Just like \textit{WizardProcess}, it is a functional component, albeit without \textit{recompose}.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Title Component,label=lst:pollTitleComponent]
const WizardStageTitle = (props) => {
  if (props.title.length == 0) {
    props.updateTitle("Poll: " + props.trainingTitle)
  }
  return (
    <View style={props.styles.stageContainer}>
      <Text style={props.styles.header}>
        {I18n.t('SOFA_wizard_header_title')}
      </Text>
      <FormTextInput
        value={props.title}
        label=''
        maxLength={50}
        placeholder={`${I18n.t('SOFA_wizard_title_placeholder')}`}
        onChangeText={props.updateTitle} />
    </View>
  );
};
export default WizardStageTitle;
\end{lstlisting}

If the component is initialised the first time, still having an empty string as a value for \textit{title}, which is given to the component as a property, the component gives it a default value, consisting of the value "Poll: " and the original training title, which is also a property. In \textit{\ref{ssec:component_structure} \nameref{ssec:component_structure}} you can see that the training title is in turn provided as a property to the \textit{WizardProcess} component.
\newline
Other than that, the component makes use of the \textit{FormTextInput}, which is a custom styled text entry field component. The callback function is referenced in the "onChangeText" property. Furthermore, the component is referencing the \textit{I18n} component, which can load specified strings for different languages, making it easy to translate the application into different languages and changing them as needed. The style of the components is also loaded as property, since \textit{WizardProcess} defines most styles to keep the style consistent throughout all \textit{WizardStage} components.

\subsubsection{Team Selection}

\label{sssec:poll_team}

TODO Patrick

\subsubsection{Addition of Guests}
\label{sssec:poll_guests}
The \textit{WizardStageGuests} component allows the user to invite guests via email to participate in the voting for the exercise for a specific training. One condition for this is that the email that is invite to the poll is already registered in the \textit{Connected.Football} environment. 
\newline
In Listing \ref{lst:pollGuestsComponent} 
\begin{lstlisting}[language=javascript, caption=Simplified Guest Component, label=lst:pollGuestsComponent]
return (
    <ApolloConsumer>
      {client => ...
        }
        return (
          <View>
            <View style={props.styles.stageContainer}>
              <Text style={props.styles.header}>
                {I18n.t('SOFA_wizard_header_guests')}
              </Text>
              <FormTextInput
                value={props.email}
                label={`${I18n.t('SOFA_wizard_guests_email')}`}
                maxLength={50}
                type='email-address'
                placeholder={`${I18n.t('SOFA_wizard_guests_enter_email')}`}
                onChangeText={props.updateEmail}
              />
              <Button
                title={`${I18n.t('SOFA_wizard_guests_add_button')}`}
                color='green'
                onPress={onPress}
              />
            </View>
            <FlatList
              data={props.emailArray}
              extraData={props.updateView}
              renderItem={({ item }) => (
              ...
              )}
              keyExtractor={(item, index) => index.toString()}
            />
          </View>
        )
      }}
    </ApolloConsumer>
  )
}
\end{lstlisting}

\subsubsection{Choice of Exercises}
\label{sssec:poll_exercises}

TODO Marco

\subsubsection{Due Date Settings}
\label{sssec:poll_due_date}

The component that takes user input regarding the due date of a poll, which is called \textit{WizardStageDueDate}, as seen in Listing \ref{lst:pollDueDateComponent}, is very similar to the component mentioned in \textit{\ref{sssec:poll_title} \nameref{sssec:poll_title}}. It is again a simple functional component which receives relevant values as properties to render the user input field.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Due Date Component,label=lst:pollDueDateComponent]
const WizardStageDueDate = (props) => {
  return (
    <View style={props.styles.stageContainer}>
      <Text style={props.styles.header}>
        {I18n.t('SOFA_wizard_header_due_date')}
      </Text>
      <DateTimePicker
        label="SOFA_wizard_due_date"
        trainingDate={props.dueDate}
        setTrainingDate={props.updateDueDate}
      />
      <View style={styles.hintContainer}>
        <Text style={styles.hintText}>
          {I18n.t('SOFA_wizard_due_date_hint')}
        </Text>
      </View>
    </View>
  );
};
export default WizardStageDueDate;
\end{lstlisting}

The component makes use of another component called \textit{DateTimePicker}, which is a custom component that opens a dialog which is native to the mobile OS the application was deployed to, which lets the user pick a date and time. Once a user has chosen a time, the component calls the supplied callback function, in this case "updateDueDate".
\newline
Given the nature of a poll, this due date of course has to be before the date of the actual training. Such a check is absent in the component mentioned above. The actual check is done by the \textit{WizardProcess} component, which handles most of the logic.

\begin{lstlisting}[language=javascript,caption=Increment Stage Check,label=lst:incrementStageCheck]
{((stage == 0 && title != '') ||
   stage == 1 ||
   stage == 2 ||
   stage == 3 ||
   ((stage == 4) && (dueDate > new Date().addDays(1)) && (dueDate.addHours(2) < trainingDate))
) &&
  <TouchableOpacity onPress={incrementStage}>
    <Icon name='arrow-circle-right' size={60} />
  </TouchableOpacity>
}
\end{lstlisting}

The source code listed in Listing \ref{lst:incrementStageCheck} shows the check as to whether to show the button which advances the Setup Wizard to it's next stage. The button is only rendered when certain conditions are met, for instance, in stage 0, which makes use of the component \textit{WizardStageTitle}, the title itself must not be empty. In the same way, the entered due date must be at least one day in the future, so that users have time to vote, and at least two hours before the start of the training.
\newline
As far as state is concerned, the component acts the same way as \textit{WizardStageTitle}. Once the callback function is called, the state is stored into the variable "dueDate" and is available to be used in the entire Setup Wizard components and it's sub-components.

\subsubsection{Check of Settings}
\label{sssec:poll_check}

TODO Marco Check and proof-read section, add information as you see fit 

Listing \ref{lst:pollCheckComponent} shows a simplified version of the \textit{WizardStageCheck} component. Again a functional component, the component seems to include quite a lot, yet it is actually only responsible for showing the already entered values to the user. The amount of source code simply comes from the amount of information that needs to be displayed, which includes information from all previous \textit{WizardStage} components.

\begin{lstlisting}[language=javascript,caption=Simplified Poll Check Component,label=lst:pollCheckComponent]
const WizardStageCheck = (props) => {
  return (
    <View>
      <Text>{I18n.t('SOFA_wizard_header_check')}</Text>
      <View>
        <FormLabel>{I18n.t('SOFA_wizard_title')}</FormLabel>
        <View>
          <Text>{props.title}</Text>
        </View>
        {props.emailArray.length > 0 &&
          <View>
            <FormLabel>{I18n.t('SOFA_wizard_guests')}</FormLabel>
            <View>
              <FlatList
                data={props.emailArray}
                renderItem={({ item }) => (
                  <View>
                    <Text>{item.email}</Text>
                  </View>
                )}
                keyExtractor={(item, index) => index.toString()}/>
            </View>
          </View>
        }
        <FormLabel>{I18n.t('SOFA_wizard_exercises')}</FormLabel>
        <View>
          <Text>{props.pollExercises}</Text>
        </View>
        <FormLabel>{I18n.t('SOFA_wizard_due_date')}</FormLabel>
        <View>
          <Icon name="date-range" size={40} />
          <Text>{moment(props.dueDate).format('DD-MM-YYYY H:mm')}</Text>
        </View>
      </View>
    </View>
  );
};
export default WizardStageCheck;
\end{lstlisting}

The component itself does not actually trigger any callback method, as the interaction for sending the checked information is actually part of the stage buttons displayed by the \textit{WizardProcess} component. Listing \ref{lst:wizardComponentWithRecompose} in \textit{\ref{ssec:poll_wizard} \nameref{ssec:poll_wizard}} contains the button which calls the handler method "buildVote4FunObject", which is responsible for sending the entered information to the \textit{Connected.Football} backend. This handler method can be seen in Listing \ref{lst:buildVote4FunObject}.

\begin{lstlisting}[language=javascript,caption=\textit{buildVote4FunObject} Handler Method,label=lst:buildVote4FunObject]
[...]
export default compose(
  //[...]
  withHandlers({
    buildVote4FunObject: props => () => {
      const exercises = [];
      props.pollExercises.forEach(function (entry) {
        exercises.push({ "exerciseId": entry.id, "playerIds": [] });
      })
      const v4l = {
        "type": "clubteam",
        "title": props.title,
        "deadline": props.dueDate,
        "showIntermediaResults": false,
        "showFinalResults": false,
        "notificationHoursBeforeDeadline": 1,
        "notificationAfterPercentageVoted": 50,
        "guestIDs": emailArray,
        "exercises": exercises
      }
      props.action({ type: 'setVote4Fun', text:v4l });
      props.navigator.pop();
    },
  }),
  //[...]
)(WizardProcess)
\end{lstlisting}

This method builds a JSON object that consists of all the information entered by the user as well as some default values that can be changed by the owner of the poll later, such as whether to show intermediate results or when to send notifications to users. One thing to pay attention to is how the "exercises" array is constructed. The array does not only consist of the IDs of exercises, like the "pollExercises" array that was constructed by the \textit{WizardStageExercises} component (see \textit{\ref{sssec:poll_exercises} \nameref{sssec:poll_exercises}}), but of objects containing both one the mentioned IDs as well as an empty array called "playerIds". This empty array is later filled with the ID of an user, whenever this user votes for this specific exercise in the poll. This way it can be tracked who already voted and which exercises got how many views.
\newline
The constructed JSON object is then propagated to the "action" property. This property is handed down from the component creating the training planner, which includes the storing of said object as well as the \textit{GraphQL} mutation to store the poll together with the entire training plan. A simplified version of this functionality can be seen in Listing \ref{lst:trainingPlannerGraphQL}.

\begin{lstlisting}[language=javascript,caption=Simplified Training Planner Component with \textit{GraphQL} Mutation,label=lst:trainingPlannerGraphQL]
const actions = {
  //[...]
  setVote4Fun: (s, action) => Object.assign({}, s, {
    vote4fun: action.text,
  }),
};
//[...]
const SAVE_PROGRAM_MUTATION = gql`
  mutation SaveProgram($payload: JSON!) {
    saveProgram(payload: $payload) {
        data
        ...ProgramListItem
      }
  }
  ${PROGRAM_LIST_FRAGMENT}
`;
//[...]
export default compose(
  //[...]
  graphql(SAVE_PROGRAM_MUTATION),
  withReducer('programState', 'action', reducer, ({ program }) => {
    return {
      id: program.id,
      //[...]
      vote4fun: program.vote4fun || [],
    };
  }),
  withHandlers({
    saveProgram: props => () => {
      props.mutate({
        variables: {
          payload: transformReducerToPayload(props.programState),
        },
        update: (store, { data: { saveProgram } }) => {
          const data = store.readQuery({ query: PROGRAMS_QUERY });
          data.getPrograms.unshift(saveProgram);
          store.writeQuery({ query: PROGRAMS_QUERY, data });
        },
      });;
    },
  ),
)(TabView);
\end{lstlisting}

The "action" that is given to the Setup Wizard is defined at the very beginning. This callback simply receives the input of the callback call and stores the text that comes with it in a variable "vote4fun". The rest shows how all entered values of a training, including the values entered in the Setup Wizard, are merged into a "reducer" which is in turn sent as a \textit{GraphQL} mutation.
\newline
The mutation itself is defined in the lines 8-15. The mutation references "SaveProgram", which is a mutation endpoint provided by the \textit{Connected.Football} backend. The sent object itself is defined with \textit{recompose}'s "withReducer", which returns all values of a training program, including the "vote4fun" value, as a JSON object. Note that if the value "vote4fun" is null, an empty array is sent instead, since a training planner does not necessarily require a poll to be created.
\newline
Finally, the handler method "saveProgram" takes this reducer and sends it to the backend. The reducer is taken as a payload for the mutation. The mutation returns the ID of the created training program, which can be used for other functionality, such as editing the training program. Since the "vote4fun" object is part of said program, it is of course also possible to edit the poll itself.

\subsection{Recompose \& Functional Components}
\label{ssec:recompose}

TODO Sebastian

\subsection{GraphQL}
\label{ssec:graphql}

TODO Lucas, TODO Patrick

\subsection{Problems \& Caveats}
\label{ssec:problems}

TODO Patrick

\subsubsection{Debugging}
\label{sssec:debugging}

TODO Patrick

\subsubsection{Package Management}
\label{sssec:package_management}

TODO Lucas

\subsubsection{Configuration Problems}
\label{sssec:configuration_problems}

TODO Patrick